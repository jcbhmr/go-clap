package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"runtime/debug"
	"strconv"
	"strings"
	"text/template"
)

var bi = func() *debug.BuildInfo {
	bi, ok := debug.ReadBuildInfo()
	if !ok {
		panic(errors.New("debug.ReadBuildInfo(): not ok"))
	}
	return bi
}()

func Usage() {
	w := flag.CommandLine.Output()
	fmt.Fprintf(w, "%s v%s", bi.Path, bi.Main.Version)
	fmt.Fprintf(w, "#[derive(...)] for Go\n")
	fmt.Fprintf(w, "Learn more at https://pkg.go.dev/%s\n", bi.Path)
	fmt.Fprintf(w, "Usage of %s:\n", bi.Path)
	flag.PrintDefaults()
}

var version = flag.Bool("v", false, "Print version")
var gofile *os.File
var goline int
var gopackage string

func FatalfHelp(format string, args ...any) {
	log.Printf(format, args...)
	log.Println()
	flag.Usage()
	os.Exit(1)
}

func ParseExtra() {
	if *version {
		fmt.Printf("%s v%s\n", bi.Path, bi.Main.Version)
		os.Exit(0)
	}

	envGofile := os.Getenv("GOFILE")
	if envGofile == "" {
		FatalfHelp("env GOFILE not set")
	}
	var err error
	gofile, err = os.Open(envGofile)
	if err != nil {
		FatalfHelp("os.Open() %s: %v", envGofile, err)
	}

	envGoline := os.Getenv("GOLINE")
	if envGoline == "" {
		FatalfHelp("env GOLINE not set")
	}
	golineInt64, err := strconv.ParseInt(envGoline, 10, 32)
	if err != nil {
		FatalfHelp("strconv.ParseInt() GOLINE=%s: %v", envGoline, err)
	}
	if golineInt64 < 0 {
		FatalfHelp("env GOLINE must be >=1")
	}
	goline = int(golineInt64)

	gopackage = os.Getenv("GOPACKAGE")
	if gopackage == "" {
		FatalfHelp("env GOPACKAGE not set")
	}
}

func main() {
	log.SetFlags(0)
	flag.Usage = Usage
	flag.Parse()
	ParseExtra()

	src, err := io.ReadAll(gofile)
	if err != nil {
		log.Fatalf("io.ReadAll() %s: %v", gofile.Name(), err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, gofile.Name(), src, parser.ParseComments)
	if err != nil {
		log.Fatalf("Could not parse file %s: %v", gofile.Name(), err)
	}

	var nextLineFirstCharPos int = 1
	for i, line := range strings.Split(string(src), "\n") {
		lineno := i + 1
		nextLineFirstCharPos += len(line) + 1
		if lineno == goline {
			break
		}
	}

	var nextDecl ast.Decl
	for _, decl := range f.Decls {
		if int(decl.Pos()) >= nextLineFirstCharPos {
			nextDecl = decl
			break
		}
	}
	if nextDecl == nil {
		log.Fatalf("Could next ast.Decl line>%d pos>=%d", goline, nextLineFirstCharPos)
	}

	genDecl, ok := nextDecl.(*ast.GenDecl)
	if !ok {
		log.Fatalf("nextDecl not *ast.GenDecl: expected *ast.GenDecl got %T", nextDecl)
	}

	if genDecl.Tok != token.TYPE {
		log.Fatalf("genDecl not token.TYPE: expected token.TYPE got %s", genDecl.Tok)
	}

	// log.Printf("genDecl:")
	// log.Printf("  .Doc.Text()=%#+v", genDecl.Doc.Text())
	// log.Printf("  .Tok=%#+v", genDecl.Tok)
	// log.Printf("  .Lparen=%#+v", genDecl.Lparen)
	// log.Printf("  .Specs=%#+v", genDecl.Specs)
	// log.Printf("  .Rparen=%#+v", genDecl.Rparen)

	typeSpecs := []*ast.TypeSpec{}
	for _, spec := range genDecl.Specs {
		typeSpec := spec.(*ast.TypeSpec)
		typeSpecs = append(typeSpecs, typeSpec)
	}

	if len(typeSpecs) != 1 {
		log.Fatalf("len(typeSpecs) expected 1 got %d", len(typeSpecs))
	}
	typeSpec := typeSpecs[0]

	// log.Printf("typeSpec:")
	// log.Printf("  .Doc.Text()=%#+v", typeSpec.Doc.Text())
	// log.Printf("  .Name.Name=%#+v", typeSpec.Name.Name)
	// log.Printf("  .TypeParams=%#+v", typeSpec.TypeParams)
	// log.Printf("  .Assign=%#+v", typeSpec.Assign)
	// log.Printf("  .Type=%#+v", typeSpec.Type)
	// log.Printf("  .Comment=%#+v", typeSpec.Comment)

	structType, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		log.Fatalf("typeSpec.Type not *ast.StructType: expected *ast.StructType got %T", typeSpec.Type)
	}

	// for i, field := range structType.Fields.List {
	// 	log.Printf("field[%d]:", i)
	// 	log.Printf("  .Doc.Text()=%#+v", field.Doc.Text())
	// 	log.Printf("  .Names=%#+v", field.Names)
	// 	log.Printf("  .Type=%#+v", field.Type)
	// 	log.Printf("  .Tag=%#+v", field.Tag)
	// 	log.Printf("  .Comment=%#+v", field.Comment)
	// }

	ctx := map[string]any{
		"name":       "clapderive/Parser",
		"gofile":     gofile,
		"goline":     goline,
		"gopackage":  gopackage,
		"genDecl":    genDecl,
		"typeSpec":   typeSpec,
		"structType": structType,
	}
	genTemplate, err := template.New("genTemplate").Parse(`// Code generated by {{.name}} DO NOT EDIT.

package {{.gopackage}}

func {{.typeSpec.Name.Name}}Parse() *{{.typeSpec.Name.Name}} {

}
`)
	if err != nil {
		log.Fatalf("template.New().Parse(): %v", err)
	}

	genCode := bytes.Buffer{}
	err = genTemplate.Execute(&genCode, ctx)
	if err != nil {
		log.Fatalf("template.Execute() %#+v: %v", ctx, err)
	}

	log.Printf("Generated code:\n%s", genCode.String())

	path := typeSpec.Name.Name + "-Parser.go"
	err = os.WriteFile(path, genCode.Bytes(), 0644)
	if err != nil {
		log.Fatalf("os.WriteFile() %s: %v", path, err)
	}

	log.Printf("Derived %s. Code is in %s", typeSpec.Name.Name, path)
}
